
bin\Debug\rf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000746  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000746  000007da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000025  00800062  00800062  000007dc  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  000007dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000050b  00000000  00000000  0000083c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d40  00000000  00000000  00000d47  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000041b  00000000  00000000  00001a87  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c2c  00000000  00000000  00001ea2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003b0  00000000  00000000  00002ad0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005cf  00000000  00000000  00002e80  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000657  00000000  00000000  0000344f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	c6 c0       	rjmp	.+396    	; 0x190 <__vector_1>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e6 e4       	ldi	r30, 0x46	; 70
  3a:	f7 e0       	ldi	r31, 0x07	; 7
  3c:	02 c0       	rjmp	.+4      	; 0x42 <.do_copy_data_start>

0000003e <.do_copy_data_loop>:
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0

00000042 <.do_copy_data_start>:
  42:	a2 36       	cpi	r26, 0x62	; 98
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <.do_copy_data_loop>

00000048 <__do_clear_bss>:
  48:	10 e0       	ldi	r17, 0x00	; 0
  4a:	a2 e6       	ldi	r26, 0x62	; 98
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a7 38       	cpi	r26, 0x87	; 135
  54:	b1 07       	cpc	r27, r17
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	4f d3       	rcall	.+1694   	; 0x6f8 <main>
  5a:	73 c3       	rjmp	.+1766   	; 0x742 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <rfReceived>:

// handles the reception of rfPacket and filling of the buffer
void rfReceived(void)
{
    // check if the receivedFlag is one if so raise assert
    receivedFlag = 1;
  5e:	81 e0       	ldi	r24, 0x01	; 1
  60:	80 93 62 00 	sts	0x0062, r24
}
  64:	08 95       	ret

00000066 <rfTransmited>:

// handles the confirmation of transmission
void rfTransmited(void)
{
    // check if the transmittedFlag is one if so raise assert
    transmittedFlag = 1;
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	80 93 63 00 	sts	0x0063, r24
}
  6c:	08 95       	ret

0000006e <rfStatus>:
// rf status
uint8_t rfStatus(void)
{
    uint8_t status;

    CSN_LOW;
  6e:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData(NOP);
  70:	8f ef       	ldi	r24, 0xFF	; 255
  72:	62 d3       	rcall	.+1732   	; 0x738 <spiSendData>
    CSN_HIGH;
  74:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
  76:	08 95       	ret

00000078 <rfFlushTx>:
// flush TX FIFO
uint8_t rfFlushTx(void)
{
    uint8_t status;

    CSN_LOW;
  78:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( FLUSH_TX );
  7a:	81 ee       	ldi	r24, 0xE1	; 225
  7c:	5d d3       	rcall	.+1722   	; 0x738 <spiSendData>
    CSN_HIGH;
  7e:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
  80:	08 95       	ret

00000082 <rfFlushRx>:
// flush rx FIFO
uint8_t rfFlushRx(void)
{
    uint8_t status;

    CSN_LOW;
  82:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( FLUSH_RX );
  84:	82 ee       	ldi	r24, 0xE2	; 226
  86:	58 d3       	rcall	.+1712   	; 0x738 <spiSendData>
    CSN_HIGH;
  88:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
  8a:	08 95       	ret

0000008c <rfStopListening>:
}

// stops listening
void rfStopListening(void)
{
    CE_LOW;
  8c:	c6 98       	cbi	0x18, 6	; 24
    rfFlushTx();
  8e:	f4 df       	rcall	.-24     	; 0x78 <rfFlushTx>
    rfFlushRx();
  90:	f8 df       	rcall	.-16     	; 0x82 <rfFlushRx>
    rfState = RF_IDLE;
  92:	10 92 65 00 	sts	0x0065, r1
  96:	10 92 64 00 	sts	0x0064, r1
}
  9a:	08 95       	ret

0000009c <rfReadPayload>:
    return status;
}

// reads the rfPayload into local buffer
uint8_t rfReadPayload(uint8_t len)
{
  9c:	ef 92       	push	r14
  9e:	ff 92       	push	r15
  a0:	0f 93       	push	r16
  a2:	1f 93       	push	r17
  a4:	f8 2e       	mov	r15, r24
    uint8_t status;

    CSN_LOW;
  a6:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( R_RX_PAYLOAD );
  a8:	81 e6       	ldi	r24, 0x61	; 97
  aa:	46 d3       	rcall	.+1676   	; 0x738 <spiSendData>
  ac:	e8 2e       	mov	r14, r24
  ae:	0e c0       	rjmp	.+28     	; 0xcc <rfReadPayload+0x30>
    while ( len-- )
        *rfPtrBuffer++ = spiSendData(NOP);
  b0:	10 91 60 00 	lds	r17, 0x0060
  b4:	00 91 61 00 	lds	r16, 0x0061
  b8:	8f ef       	ldi	r24, 0xFF	; 255
  ba:	3e d3       	rcall	.+1660   	; 0x738 <spiSendData>
  bc:	e1 2f       	mov	r30, r17
  be:	f0 2f       	mov	r31, r16
  c0:	81 93       	st	Z+, r24
  c2:	f0 93 61 00 	sts	0x0061, r31
  c6:	e0 93 60 00 	sts	0x0060, r30
  ca:	fa 94       	dec	r15
{
    uint8_t status;

    CSN_LOW;
    status = spiSendData( R_RX_PAYLOAD );
    while ( len-- )
  cc:	ff 20       	and	r15, r15
  ce:	81 f7       	brne	.-32     	; 0xb0 <rfReadPayload+0x14>
        *rfPtrBuffer++ = spiSendData(NOP);
    CSN_HIGH;
  d0:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
  d2:	8e 2d       	mov	r24, r14
  d4:	1f 91       	pop	r17
  d6:	0f 91       	pop	r16
  d8:	ff 90       	pop	r15
  da:	ef 90       	pop	r14
  dc:	08 95       	ret

000000de <rfWriteAckPayload>:
    return status;
}

// writes the rfAckPayload from local buffer
uint8_t rfWriteAckPayload(const uint8_t* buf, uint8_t len)
{
  de:	0f 93       	push	r16
  e0:	1f 93       	push	r17
  e2:	cf 93       	push	r28
  e4:	df 93       	push	r29
  e6:	ec 01       	movw	r28, r24
  e8:	16 2f       	mov	r17, r22
    uint8_t status;

    CSN_LOW;
  ea:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( W_ACK_PAYLOAD );
  ec:	88 ea       	ldi	r24, 0xA8	; 168
  ee:	24 d3       	rcall	.+1608   	; 0x738 <spiSendData>
  f0:	08 2f       	mov	r16, r24
  f2:	03 c0       	rjmp	.+6      	; 0xfa <rfWriteAckPayload+0x1c>
    while ( len-- )
        spiSendData(*buf++);
  f4:	89 91       	ld	r24, Y+
  f6:	20 d3       	rcall	.+1600   	; 0x738 <spiSendData>
  f8:	11 50       	subi	r17, 0x01	; 1
{
    uint8_t status;

    CSN_LOW;
    status = spiSendData( W_ACK_PAYLOAD );
    while ( len-- )
  fa:	11 23       	and	r17, r17
  fc:	d9 f7       	brne	.-10     	; 0xf4 <rfWriteAckPayload+0x16>
        spiSendData(*buf++);
    CSN_HIGH;
  fe:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
 100:	80 2f       	mov	r24, r16
 102:	df 91       	pop	r29
 104:	cf 91       	pop	r28
 106:	1f 91       	pop	r17
 108:	0f 91       	pop	r16
 10a:	08 95       	ret

0000010c <rfWritePayload>:
    return status;
}

// writes the rfPayload from local buffer
uint8_t rfWritePayload(const uint8_t* buf, uint8_t len)
{
 10c:	0f 93       	push	r16
 10e:	1f 93       	push	r17
 110:	cf 93       	push	r28
 112:	df 93       	push	r29
 114:	ec 01       	movw	r28, r24
 116:	16 2f       	mov	r17, r22
    uint8_t status;

    CSN_LOW;
 118:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( W_TX_PAYLOAD );
 11a:	80 ea       	ldi	r24, 0xA0	; 160
 11c:	0d d3       	rcall	.+1562   	; 0x738 <spiSendData>
 11e:	08 2f       	mov	r16, r24
 120:	03 c0       	rjmp	.+6      	; 0x128 <rfWritePayload+0x1c>
    while ( len-- )
        spiSendData(*buf++);
 122:	89 91       	ld	r24, Y+
 124:	09 d3       	rcall	.+1554   	; 0x738 <spiSendData>
 126:	11 50       	subi	r17, 0x01	; 1
{
    uint8_t status;

    CSN_LOW;
    status = spiSendData( W_TX_PAYLOAD );
    while ( len-- )
 128:	11 23       	and	r17, r17
 12a:	d9 f7       	brne	.-10     	; 0x122 <rfWritePayload+0x16>
        spiSendData(*buf++);
    CSN_HIGH;
 12c:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
 12e:	80 2f       	mov	r24, r16
 130:	df 91       	pop	r29
 132:	cf 91       	pop	r28
 134:	1f 91       	pop	r17
 136:	0f 91       	pop	r16
 138:	08 95       	ret

0000013a <rfWriteRegChar>:
    return status;
}

// writes to the register
uint8_t rfWriteRegChar(uint8_t reg, uint8_t value)
{
 13a:	0f 93       	push	r16
 13c:	1f 93       	push	r17
 13e:	06 2f       	mov	r16, r22
    uint8_t status;

    CSN_LOW;
 140:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( W_REGISTER | reg );
 142:	80 62       	ori	r24, 0x20	; 32
 144:	f9 d2       	rcall	.+1522   	; 0x738 <spiSendData>
 146:	18 2f       	mov	r17, r24
    spiSendData(value);
 148:	80 2f       	mov	r24, r16
 14a:	f6 d2       	rcall	.+1516   	; 0x738 <spiSendData>
    CSN_HIGH;
 14c:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
 14e:	81 2f       	mov	r24, r17
 150:	1f 91       	pop	r17
 152:	0f 91       	pop	r16
 154:	08 95       	ret

00000156 <rfWriteRegBuff>:
    return result;
}

// writes to the register from buffer
uint8_t rfWriteRegBuff(uint8_t reg, const uint8_t* buf, uint8_t len)
{
 156:	0f 93       	push	r16
 158:	1f 93       	push	r17
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	eb 01       	movw	r28, r22
 160:	14 2f       	mov	r17, r20
    uint8_t status;

    CSN_LOW;
 162:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( W_REGISTER | reg );
 164:	80 62       	ori	r24, 0x20	; 32
 166:	e8 d2       	rcall	.+1488   	; 0x738 <spiSendData>
 168:	08 2f       	mov	r16, r24
 16a:	03 c0       	rjmp	.+6      	; 0x172 <rfWriteRegBuff+0x1c>
    while ( len-- )
        spiSendData(*buf++);
 16c:	89 91       	ld	r24, Y+
 16e:	e4 d2       	rcall	.+1480   	; 0x738 <spiSendData>
 170:	11 50       	subi	r17, 0x01	; 1
{
    uint8_t status;

    CSN_LOW;
    status = spiSendData( W_REGISTER | reg );
    while ( len-- )
 172:	11 23       	and	r17, r17
 174:	d9 f7       	brne	.-10     	; 0x16c <rfWriteRegBuff+0x16>
        spiSendData(*buf++);
    CSN_HIGH;
 176:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
 178:	80 2f       	mov	r24, r16
 17a:	df 91       	pop	r29
 17c:	cf 91       	pop	r28
 17e:	1f 91       	pop	r17
 180:	0f 91       	pop	r16
 182:	08 95       	ret

00000184 <rfReadRegChar>:
}

// reads the register and returns it
uint8_t rfReadRegChar(uint8_t reg)
{
    CSN_LOW;
 184:	c7 98       	cbi	0x18, 7	; 24
    spiSendData( R_REGISTER | reg );
 186:	d8 d2       	rcall	.+1456   	; 0x738 <spiSendData>
    uint8_t result = spiSendData(0xff);
 188:	8f ef       	ldi	r24, 0xFF	; 255
 18a:	d6 d2       	rcall	.+1452   	; 0x738 <spiSendData>
    CSN_HIGH;
 18c:	c7 9a       	sbi	0x18, 7	; 24

    return result;
}
 18e:	08 95       	ret

00000190 <__vector_1>:
/** \brief
 *
 *
 */
ISR(EXT_INT)
{
 190:	1f 92       	push	r1
 192:	0f 92       	push	r0
 194:	0f b6       	in	r0, 0x3f	; 63
 196:	0f 92       	push	r0
 198:	11 24       	eor	r1, r1
 19a:	2f 93       	push	r18
 19c:	3f 93       	push	r19
 19e:	4f 93       	push	r20
 1a0:	5f 93       	push	r21
 1a2:	6f 93       	push	r22
 1a4:	7f 93       	push	r23
 1a6:	8f 93       	push	r24
 1a8:	9f 93       	push	r25
 1aa:	af 93       	push	r26
 1ac:	bf 93       	push	r27
 1ae:	cf 93       	push	r28
 1b0:	df 93       	push	r29
 1b2:	ef 93       	push	r30
 1b4:	ff 93       	push	r31
    uint8_t status;
    status = rfStatus();
 1b6:	5b df       	rcall	.-330    	; 0x6e <rfStatus>

    if(CHECK_BIT(status, RX_DR))
 1b8:	c8 2f       	mov	r28, r24
 1ba:	86 ff       	sbrs	r24, 6
 1bc:	0e c0       	rjmp	.+28     	; 0x1da <__vector_1+0x4a>
    {
        SET_BIT(status, RX_DR);
        rfState = RF_DATA_RECEIVED;
 1be:	82 e0       	ldi	r24, 0x02	; 2
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	90 93 65 00 	sts	0x0065, r25
 1c6:	80 93 64 00 	sts	0x0064, r24

// handles the reception of rfPacket and filling of the buffer
void rfReceived(void)
{
    // check if the receivedFlag is one if so raise assert
    receivedFlag = 1;
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 62 00 	sts	0x0062, r24
    {
        SET_BIT(status, RX_DR);
        rfState = RF_DATA_RECEIVED;
		LED_ON;
        rfReceived();
        uint8_t length = rfReadRegChar(R_RX_PL_WID);
 1d0:	80 e6       	ldi	r24, 0x60	; 96
 1d2:	d8 df       	rcall	.-80     	; 0x184 <rfReadRegChar>
        rfLength = length;
 1d4:	80 93 66 00 	sts	0x0066, r24
        rfReadPayload(length);
 1d8:	61 df       	rcall	.-318    	; 0x9c <rfReadPayload>
		LED_OFF;
    }

    if(CHECK_BIT(status, TX_DS))
 1da:	c5 ff       	sbrs	r28, 5
 1dc:	09 c0       	rjmp	.+18     	; 0x1f0 <__vector_1+0x60>
    {
        SET_BIT(status, TX_DS);
        rfState = RF_TRANSMIT_SUCCESS;
 1de:	84 e0       	ldi	r24, 0x04	; 4
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	90 93 65 00 	sts	0x0065, r25
 1e6:	80 93 64 00 	sts	0x0064, r24

// handles the confirmation of transmission
void rfTransmited(void)
{
    // check if the transmittedFlag is one if so raise assert
    transmittedFlag = 1;
 1ea:	81 e0       	ldi	r24, 0x01	; 1
 1ec:	80 93 63 00 	sts	0x0063, r24
        rfState = RF_TRANSMIT_SUCCESS;
		LED_OFF;
        rfTransmited();
    }

    if(CHECK_BIT(status, MAX_RT))
 1f0:	c4 ff       	sbrs	r28, 4
 1f2:	06 c0       	rjmp	.+12     	; 0x200 <__vector_1+0x70>
    {
        SET_BIT(status, MAX_RT);
		// packet transmit failed
		rfState = RF_TRANSMIT_FAIL;
 1f4:	85 e0       	ldi	r24, 0x05	; 5
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	90 93 65 00 	sts	0x0065, r25
 1fc:	80 93 64 00 	sts	0x0064, r24
    }
}
 200:	ff 91       	pop	r31
 202:	ef 91       	pop	r30
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	bf 91       	pop	r27
 20a:	af 91       	pop	r26
 20c:	9f 91       	pop	r25
 20e:	8f 91       	pop	r24
 210:	7f 91       	pop	r23
 212:	6f 91       	pop	r22
 214:	5f 91       	pop	r21
 216:	4f 91       	pop	r20
 218:	3f 91       	pop	r19
 21a:	2f 91       	pop	r18
 21c:	0f 90       	pop	r0
 21e:	0f be       	out	0x3f, r0	; 63
 220:	0f 90       	pop	r0
 222:	1f 90       	pop	r1
 224:	18 95       	reti

00000226 <rfRxFifoStatus>:
}

// status about the RX FIFO status
uint8_t rfRxFifoStatus(void)
{
    uint8_t status = rfReadRegChar(FIFO_STATUS);
 226:	87 e1       	ldi	r24, 0x17	; 23
 228:	ad df       	rcall	.-166    	; 0x184 <rfReadRegChar>
    return (CHECK_BIT(status,RX_FULL));
}
 22a:	82 70       	andi	r24, 0x02	; 2
 22c:	08 95       	ret

0000022e <rfTxFifoStatus>:
}

// status about the TX FIFO status
uint8_t rfTxFifoStatus(void)
{
    uint8_t status = rfReadRegChar(FIFO_STATUS);
 22e:	87 e1       	ldi	r24, 0x17	; 23
 230:	a9 df       	rcall	.-174    	; 0x184 <rfReadRegChar>
    return (CHECK_BIT(status,TX_FULL));
}
 232:	80 72       	andi	r24, 0x20	; 32
 234:	08 95       	ret

00000236 <rfDisableGlobalDynamicAckPayload>:
}

// disable dynamic payload
void rfDisableGlobalDynamicAckPayload(void)
{
    rfWriteRegChar(FEATURE, CLEAR_BIT(rfReadRegChar(FEATURE), EN_DYN_ACK));
 236:	8d e1       	ldi	r24, 0x1D	; 29
 238:	a5 df       	rcall	.-182    	; 0x184 <rfReadRegChar>
 23a:	68 2f       	mov	r22, r24
 23c:	6e 7f       	andi	r22, 0xFE	; 254
 23e:	8d e1       	ldi	r24, 0x1D	; 29
 240:	7c df       	rcall	.-264    	; 0x13a <rfWriteRegChar>
}
 242:	08 95       	ret

00000244 <rfEnableGlobalDynamicAckPayload>:
}

// enables dynamic payload
void rfEnableGlobalDynamicAckPayload(void)
{
    rfWriteRegChar(FEATURE, SET_BIT(rfReadRegChar(FEATURE), EN_DYN_ACK));
 244:	8d e1       	ldi	r24, 0x1D	; 29
 246:	9e df       	rcall	.-196    	; 0x184 <rfReadRegChar>
 248:	68 2f       	mov	r22, r24
 24a:	61 60       	ori	r22, 0x01	; 1
 24c:	8d e1       	ldi	r24, 0x1D	; 29
 24e:	75 df       	rcall	.-278    	; 0x13a <rfWriteRegChar>
}
 250:	08 95       	ret

00000252 <rfDisableGlobalAckPayload>:
}

// disable Ack payload
void rfDisableGlobalAckPayload(void)
{
    rfWriteRegChar(FEATURE, CLEAR_BIT(rfReadRegChar(FEATURE), EN_ACK_PAY));
 252:	8d e1       	ldi	r24, 0x1D	; 29
 254:	97 df       	rcall	.-210    	; 0x184 <rfReadRegChar>
 256:	68 2f       	mov	r22, r24
 258:	6d 7f       	andi	r22, 0xFD	; 253
 25a:	8d e1       	ldi	r24, 0x1D	; 29
 25c:	6e df       	rcall	.-292    	; 0x13a <rfWriteRegChar>
}
 25e:	08 95       	ret

00000260 <rfEnableGlobalAckPayload>:
}

// enable Ack payload
void rfEnableGlobalAckPayload(void)
{
    rfWriteRegChar(FEATURE, SET_BIT(rfReadRegChar(FEATURE), EN_ACK_PAY));
 260:	8d e1       	ldi	r24, 0x1D	; 29
 262:	90 df       	rcall	.-224    	; 0x184 <rfReadRegChar>
 264:	68 2f       	mov	r22, r24
 266:	62 60       	ori	r22, 0x02	; 2
 268:	8d e1       	ldi	r24, 0x1D	; 29
 26a:	67 df       	rcall	.-306    	; 0x13a <rfWriteRegChar>
}
 26c:	08 95       	ret

0000026e <rfDisableGlobalDynamicPayload>:
}

// enable dynamic payload
void rfDisableGlobalDynamicPayload(void)
{
    rfWriteRegChar(FEATURE, CLEAR_BIT(rfReadRegChar(FEATURE), EN_DPL));
 26e:	8d e1       	ldi	r24, 0x1D	; 29
 270:	89 df       	rcall	.-238    	; 0x184 <rfReadRegChar>
 272:	68 2f       	mov	r22, r24
 274:	6b 7f       	andi	r22, 0xFB	; 251
 276:	8d e1       	ldi	r24, 0x1D	; 29
 278:	60 df       	rcall	.-320    	; 0x13a <rfWriteRegChar>
}
 27a:	08 95       	ret

0000027c <rfEnableGlobalDynamicPayload>:
}

// enable dynamic payload
void rfEnableGlobalDynamicPayload(void)
{
    rfWriteRegChar(FEATURE, SET_BIT(rfReadRegChar(FEATURE), EN_DPL));
 27c:	8d e1       	ldi	r24, 0x1D	; 29
 27e:	82 df       	rcall	.-252    	; 0x184 <rfReadRegChar>
 280:	68 2f       	mov	r22, r24
 282:	64 60       	ori	r22, 0x04	; 4
 284:	8d e1       	ldi	r24, 0x1D	; 29
 286:	59 df       	rcall	.-334    	; 0x13a <rfWriteRegChar>
}
 288:	08 95       	ret

0000028a <rfClearDynamicPayloadForPipe>:
}

// enables dynamic payload for a pipe
void rfClearDynamicPayloadForPipe(uint8_t dymamic)
{
    if (DPL_P0 == dymamic)
 28a:	88 23       	and	r24, r24
 28c:	29 f4       	brne	.+10     	; 0x298 <rfClearDynamicPayloadForPipe+0xe>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P0));
 28e:	8c e1       	ldi	r24, 0x1C	; 28
 290:	79 df       	rcall	.-270    	; 0x184 <rfReadRegChar>
 292:	68 2f       	mov	r22, r24
 294:	6e 7f       	andi	r22, 0xFE	; 254
 296:	1b c0       	rjmp	.+54     	; 0x2ce <rfClearDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P1 == dymamic)
 298:	81 30       	cpi	r24, 0x01	; 1
 29a:	29 f4       	brne	.+10     	; 0x2a6 <rfClearDynamicPayloadForPipe+0x1c>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P1));
 29c:	8c e1       	ldi	r24, 0x1C	; 28
 29e:	72 df       	rcall	.-284    	; 0x184 <rfReadRegChar>
 2a0:	68 2f       	mov	r22, r24
 2a2:	6d 7f       	andi	r22, 0xFD	; 253
 2a4:	14 c0       	rjmp	.+40     	; 0x2ce <rfClearDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P2 == dymamic)
 2a6:	82 30       	cpi	r24, 0x02	; 2
 2a8:	29 f4       	brne	.+10     	; 0x2b4 <rfClearDynamicPayloadForPipe+0x2a>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P2));
 2aa:	8c e1       	ldi	r24, 0x1C	; 28
 2ac:	6b df       	rcall	.-298    	; 0x184 <rfReadRegChar>
 2ae:	68 2f       	mov	r22, r24
 2b0:	6b 7f       	andi	r22, 0xFB	; 251
 2b2:	0d c0       	rjmp	.+26     	; 0x2ce <rfClearDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P3 == dymamic)
 2b4:	83 30       	cpi	r24, 0x03	; 3
 2b6:	29 f4       	brne	.+10     	; 0x2c2 <rfClearDynamicPayloadForPipe+0x38>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P3));
 2b8:	8c e1       	ldi	r24, 0x1C	; 28
 2ba:	64 df       	rcall	.-312    	; 0x184 <rfReadRegChar>
 2bc:	68 2f       	mov	r22, r24
 2be:	67 7f       	andi	r22, 0xF7	; 247
 2c0:	06 c0       	rjmp	.+12     	; 0x2ce <rfClearDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P4 == dymamic)
 2c2:	84 30       	cpi	r24, 0x04	; 4
 2c4:	39 f4       	brne	.+14     	; 0x2d4 <rfClearDynamicPayloadForPipe+0x4a>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P4));
 2c6:	8c e1       	ldi	r24, 0x1C	; 28
 2c8:	5d df       	rcall	.-326    	; 0x184 <rfReadRegChar>
 2ca:	68 2f       	mov	r22, r24
 2cc:	6f 7e       	andi	r22, 0xEF	; 239
 2ce:	8c e1       	ldi	r24, 0x1C	; 28
 2d0:	34 df       	rcall	.-408    	; 0x13a <rfWriteRegChar>
 2d2:	08 95       	ret
    }
    else if (DPL_P5 == dymamic)
 2d4:	85 30       	cpi	r24, 0x05	; 5
 2d6:	31 f4       	brne	.+12     	; 0x2e4 <rfClearDynamicPayloadForPipe+0x5a>
    {
        rfWriteRegChar(DYNPD, CLEAR_BIT(rfReadRegChar(DYNPD), DPL_P5));
 2d8:	8c e1       	ldi	r24, 0x1C	; 28
 2da:	54 df       	rcall	.-344    	; 0x184 <rfReadRegChar>
 2dc:	68 2f       	mov	r22, r24
 2de:	6f 7d       	andi	r22, 0xDF	; 223
 2e0:	8c e1       	ldi	r24, 0x1C	; 28
 2e2:	2b df       	rcall	.-426    	; 0x13a <rfWriteRegChar>
 2e4:	08 95       	ret

000002e6 <rfSetDynamicPayloadForPipe>:
}

// enables dynamic payload for a pipe
void rfSetDynamicPayloadForPipe(uint8_t dymamic)
{
    if (DPL_P0 == dymamic)
 2e6:	88 23       	and	r24, r24
 2e8:	29 f4       	brne	.+10     	; 0x2f4 <rfSetDynamicPayloadForPipe+0xe>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P0));
 2ea:	8c e1       	ldi	r24, 0x1C	; 28
 2ec:	4b df       	rcall	.-362    	; 0x184 <rfReadRegChar>
 2ee:	68 2f       	mov	r22, r24
 2f0:	61 60       	ori	r22, 0x01	; 1
 2f2:	1b c0       	rjmp	.+54     	; 0x32a <rfSetDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P1 == dymamic)
 2f4:	81 30       	cpi	r24, 0x01	; 1
 2f6:	29 f4       	brne	.+10     	; 0x302 <rfSetDynamicPayloadForPipe+0x1c>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P1));
 2f8:	8c e1       	ldi	r24, 0x1C	; 28
 2fa:	44 df       	rcall	.-376    	; 0x184 <rfReadRegChar>
 2fc:	68 2f       	mov	r22, r24
 2fe:	62 60       	ori	r22, 0x02	; 2
 300:	14 c0       	rjmp	.+40     	; 0x32a <rfSetDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P2 == dymamic)
 302:	82 30       	cpi	r24, 0x02	; 2
 304:	29 f4       	brne	.+10     	; 0x310 <rfSetDynamicPayloadForPipe+0x2a>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P2));
 306:	8c e1       	ldi	r24, 0x1C	; 28
 308:	3d df       	rcall	.-390    	; 0x184 <rfReadRegChar>
 30a:	68 2f       	mov	r22, r24
 30c:	64 60       	ori	r22, 0x04	; 4
 30e:	0d c0       	rjmp	.+26     	; 0x32a <rfSetDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P3 == dymamic)
 310:	83 30       	cpi	r24, 0x03	; 3
 312:	29 f4       	brne	.+10     	; 0x31e <rfSetDynamicPayloadForPipe+0x38>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P3));
 314:	8c e1       	ldi	r24, 0x1C	; 28
 316:	36 df       	rcall	.-404    	; 0x184 <rfReadRegChar>
 318:	68 2f       	mov	r22, r24
 31a:	68 60       	ori	r22, 0x08	; 8
 31c:	06 c0       	rjmp	.+12     	; 0x32a <rfSetDynamicPayloadForPipe+0x44>
    }
    else if (DPL_P4 == dymamic)
 31e:	84 30       	cpi	r24, 0x04	; 4
 320:	39 f4       	brne	.+14     	; 0x330 <rfSetDynamicPayloadForPipe+0x4a>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P4));
 322:	8c e1       	ldi	r24, 0x1C	; 28
 324:	2f df       	rcall	.-418    	; 0x184 <rfReadRegChar>
 326:	68 2f       	mov	r22, r24
 328:	60 61       	ori	r22, 0x10	; 16
 32a:	8c e1       	ldi	r24, 0x1C	; 28
 32c:	06 df       	rcall	.-500    	; 0x13a <rfWriteRegChar>
 32e:	08 95       	ret
    }
    else if (DPL_P5 == dymamic)
 330:	85 30       	cpi	r24, 0x05	; 5
 332:	31 f4       	brne	.+12     	; 0x340 <rfSetDynamicPayloadForPipe+0x5a>
    {
        rfWriteRegChar(DYNPD, SET_BIT(rfReadRegChar(DYNPD), DPL_P5));
 334:	8c e1       	ldi	r24, 0x1C	; 28
 336:	26 df       	rcall	.-436    	; 0x184 <rfReadRegChar>
 338:	68 2f       	mov	r22, r24
 33a:	60 62       	ori	r22, 0x20	; 32
 33c:	8c e1       	ldi	r24, 0x1C	; 28
 33e:	fd de       	rcall	.-518    	; 0x13a <rfWriteRegChar>
 340:	08 95       	ret

00000342 <rfReadChannelPower>:
}

// reads the channel power
uint8_t rfReadChannelPower(void)
{
    return rfReadRegChar(RPD);
 342:	89 e0       	ldi	r24, 0x09	; 9
 344:	1f df       	rcall	.-450    	; 0x184 <rfReadRegChar>
}
 346:	08 95       	ret

00000348 <rfTransmitCarrier>:
}

// make the channel busy by transmitting carrier wave
void rfTransmitCarrier(void)
{
    rfWriteRegChar(RF_SETUP, SET_BIT(rfReadRegChar(RF_SETUP), CONT_WAVE));
 348:	86 e0       	ldi	r24, 0x06	; 6
 34a:	1c df       	rcall	.-456    	; 0x184 <rfReadRegChar>
 34c:	68 2f       	mov	r22, r24
 34e:	60 68       	ori	r22, 0x80	; 128
 350:	86 e0       	ldi	r24, 0x06	; 6
 352:	f3 de       	rcall	.-538    	; 0x13a <rfWriteRegChar>
}
 354:	08 95       	ret

00000356 <rfSetRetryDelay>:
    rfWriteRegChar(SETUP_RETR, SET_VALUE(rfReadRegChar(SETUP_RETR), attempts));
}

// sets the retransmit delays
void rfSetRetryDelay(uint8_t delay)
{
 356:	1f 93       	push	r17
 358:	18 2f       	mov	r17, r24
    // check for bounds
    rfWriteRegChar(SETUP_RETR, SET_VALUE(rfReadRegChar(SETUP_RETR), (delay<<4)));
 35a:	84 e0       	ldi	r24, 0x04	; 4
 35c:	13 df       	rcall	.-474    	; 0x184 <rfReadRegChar>
 35e:	12 95       	swap	r17
 360:	10 7f       	andi	r17, 0xF0	; 240
 362:	18 2b       	or	r17, r24
 364:	84 e0       	ldi	r24, 0x04	; 4
 366:	61 2f       	mov	r22, r17
 368:	e8 de       	rcall	.-560    	; 0x13a <rfWriteRegChar>
}
 36a:	1f 91       	pop	r17
 36c:	08 95       	ret

0000036e <rfSetRetryAttempts>:
    }
}

// set number of retries
void rfSetRetryAttempts(uint8_t attempts)
{
 36e:	1f 93       	push	r17
 370:	18 2f       	mov	r17, r24
    // check for bounds
    rfWriteRegChar(SETUP_RETR, SET_VALUE(rfReadRegChar(SETUP_RETR), attempts));
 372:	84 e0       	ldi	r24, 0x04	; 4
 374:	07 df       	rcall	.-498    	; 0x184 <rfReadRegChar>
 376:	18 2b       	or	r17, r24
 378:	84 e0       	ldi	r24, 0x04	; 4
 37a:	61 2f       	mov	r22, r17
 37c:	de de       	rcall	.-580    	; 0x13a <rfWriteRegChar>
}
 37e:	1f 91       	pop	r17
 380:	08 95       	ret

00000382 <rfDisablePipeForRx>:
}

// disable an address pipe
void rfDisablePipeForRx(uint8_t pipeAddress)
{
    if (ERX_P0 == pipeAddress)
 382:	88 23       	and	r24, r24
 384:	29 f4       	brne	.+10     	; 0x390 <rfDisablePipeForRx+0xe>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P0));
 386:	82 e0       	ldi	r24, 0x02	; 2
 388:	fd de       	rcall	.-518    	; 0x184 <rfReadRegChar>
 38a:	68 2f       	mov	r22, r24
 38c:	6e 7f       	andi	r22, 0xFE	; 254
 38e:	1a c0       	rjmp	.+52     	; 0x3c4 <rfDisablePipeForRx+0x42>
    }
    else if (ERX_P1 == pipeAddress)
 390:	81 30       	cpi	r24, 0x01	; 1
 392:	29 f4       	brne	.+10     	; 0x39e <rfDisablePipeForRx+0x1c>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P1));
 394:	82 e0       	ldi	r24, 0x02	; 2
 396:	f6 de       	rcall	.-532    	; 0x184 <rfReadRegChar>
 398:	68 2f       	mov	r22, r24
 39a:	6d 7f       	andi	r22, 0xFD	; 253
 39c:	13 c0       	rjmp	.+38     	; 0x3c4 <rfDisablePipeForRx+0x42>
    }
    else if (ERX_P2 == pipeAddress)
 39e:	82 30       	cpi	r24, 0x02	; 2
 3a0:	21 f4       	brne	.+8      	; 0x3aa <rfDisablePipeForRx+0x28>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P2));
 3a2:	f0 de       	rcall	.-544    	; 0x184 <rfReadRegChar>
 3a4:	68 2f       	mov	r22, r24
 3a6:	6b 7f       	andi	r22, 0xFB	; 251
 3a8:	0d c0       	rjmp	.+26     	; 0x3c4 <rfDisablePipeForRx+0x42>
    }
    else if (ERX_P3 == pipeAddress)
 3aa:	83 30       	cpi	r24, 0x03	; 3
 3ac:	29 f4       	brne	.+10     	; 0x3b8 <rfDisablePipeForRx+0x36>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P3));
 3ae:	82 e0       	ldi	r24, 0x02	; 2
 3b0:	e9 de       	rcall	.-558    	; 0x184 <rfReadRegChar>
 3b2:	68 2f       	mov	r22, r24
 3b4:	67 7f       	andi	r22, 0xF7	; 247
 3b6:	06 c0       	rjmp	.+12     	; 0x3c4 <rfDisablePipeForRx+0x42>
    }
    else if (ERX_P4 == pipeAddress)
 3b8:	84 30       	cpi	r24, 0x04	; 4
 3ba:	39 f4       	brne	.+14     	; 0x3ca <rfDisablePipeForRx+0x48>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P4));
 3bc:	82 e0       	ldi	r24, 0x02	; 2
 3be:	e2 de       	rcall	.-572    	; 0x184 <rfReadRegChar>
 3c0:	68 2f       	mov	r22, r24
 3c2:	6f 7e       	andi	r22, 0xEF	; 239
 3c4:	82 e0       	ldi	r24, 0x02	; 2
 3c6:	b9 de       	rcall	.-654    	; 0x13a <rfWriteRegChar>
 3c8:	08 95       	ret
    }
    else if (ERX_P5 == pipeAddress)
 3ca:	85 30       	cpi	r24, 0x05	; 5
 3cc:	31 f4       	brne	.+12     	; 0x3da <rfDisablePipeForRx+0x58>
    {
        rfWriteRegChar(EN_RXADDR, CLEAR_BIT(rfReadRegChar(EN_RXADDR), ERX_P5));
 3ce:	82 e0       	ldi	r24, 0x02	; 2
 3d0:	d9 de       	rcall	.-590    	; 0x184 <rfReadRegChar>
 3d2:	68 2f       	mov	r22, r24
 3d4:	6f 7d       	andi	r22, 0xDF	; 223
 3d6:	82 e0       	ldi	r24, 0x02	; 2
 3d8:	b0 de       	rcall	.-672    	; 0x13a <rfWriteRegChar>
 3da:	08 95       	ret

000003dc <rfEnablePipeForRx>:
}

// enables an address pipe
void rfEnablePipeForRx(uint8_t pipeAddress)
{
    if (ERX_P0 == pipeAddress)
 3dc:	88 23       	and	r24, r24
 3de:	29 f4       	brne	.+10     	; 0x3ea <rfEnablePipeForRx+0xe>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P0));
 3e0:	82 e0       	ldi	r24, 0x02	; 2
 3e2:	d0 de       	rcall	.-608    	; 0x184 <rfReadRegChar>
 3e4:	68 2f       	mov	r22, r24
 3e6:	61 60       	ori	r22, 0x01	; 1
 3e8:	1a c0       	rjmp	.+52     	; 0x41e <rfEnablePipeForRx+0x42>
    }
    else if (ERX_P1 == pipeAddress)
 3ea:	81 30       	cpi	r24, 0x01	; 1
 3ec:	29 f4       	brne	.+10     	; 0x3f8 <rfEnablePipeForRx+0x1c>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P1));
 3ee:	82 e0       	ldi	r24, 0x02	; 2
 3f0:	c9 de       	rcall	.-622    	; 0x184 <rfReadRegChar>
 3f2:	68 2f       	mov	r22, r24
 3f4:	62 60       	ori	r22, 0x02	; 2
 3f6:	13 c0       	rjmp	.+38     	; 0x41e <rfEnablePipeForRx+0x42>
    }
    else if (ERX_P2 == pipeAddress)
 3f8:	82 30       	cpi	r24, 0x02	; 2
 3fa:	21 f4       	brne	.+8      	; 0x404 <rfEnablePipeForRx+0x28>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P2));
 3fc:	c3 de       	rcall	.-634    	; 0x184 <rfReadRegChar>
 3fe:	68 2f       	mov	r22, r24
 400:	64 60       	ori	r22, 0x04	; 4
 402:	0d c0       	rjmp	.+26     	; 0x41e <rfEnablePipeForRx+0x42>
    }
    else if (ERX_P3 == pipeAddress)
 404:	83 30       	cpi	r24, 0x03	; 3
 406:	29 f4       	brne	.+10     	; 0x412 <rfEnablePipeForRx+0x36>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P3));
 408:	82 e0       	ldi	r24, 0x02	; 2
 40a:	bc de       	rcall	.-648    	; 0x184 <rfReadRegChar>
 40c:	68 2f       	mov	r22, r24
 40e:	68 60       	ori	r22, 0x08	; 8
 410:	06 c0       	rjmp	.+12     	; 0x41e <rfEnablePipeForRx+0x42>
    }
    else if (ERX_P4 == pipeAddress)
 412:	84 30       	cpi	r24, 0x04	; 4
 414:	39 f4       	brne	.+14     	; 0x424 <rfEnablePipeForRx+0x48>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P4));
 416:	82 e0       	ldi	r24, 0x02	; 2
 418:	b5 de       	rcall	.-662    	; 0x184 <rfReadRegChar>
 41a:	68 2f       	mov	r22, r24
 41c:	60 61       	ori	r22, 0x10	; 16
 41e:	82 e0       	ldi	r24, 0x02	; 2
 420:	8c de       	rcall	.-744    	; 0x13a <rfWriteRegChar>
 422:	08 95       	ret
    }
    else if (ERX_P5 == pipeAddress)
 424:	85 30       	cpi	r24, 0x05	; 5
 426:	31 f4       	brne	.+12     	; 0x434 <rfEnablePipeForRx+0x58>
    {
        rfWriteRegChar(EN_RXADDR, SET_BIT(rfReadRegChar(EN_RXADDR), ERX_P5));
 428:	82 e0       	ldi	r24, 0x02	; 2
 42a:	ac de       	rcall	.-680    	; 0x184 <rfReadRegChar>
 42c:	68 2f       	mov	r22, r24
 42e:	60 62       	ori	r22, 0x20	; 32
 430:	82 e0       	ldi	r24, 0x02	; 2
 432:	83 de       	rcall	.-762    	; 0x13a <rfWriteRegChar>
 434:	08 95       	ret

00000436 <rfClearAutoAckForPipe>:
}

// Clears autoack on a pipe
void rfClearAutoAckForPipe(uint8_t pipeAddress)
{
    if (ENAA_P0 == pipeAddress)
 436:	88 23       	and	r24, r24
 438:	29 f4       	brne	.+10     	; 0x444 <rfClearAutoAckForPipe+0xe>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P0));
 43a:	81 e0       	ldi	r24, 0x01	; 1
 43c:	a3 de       	rcall	.-698    	; 0x184 <rfReadRegChar>
 43e:	68 2f       	mov	r22, r24
 440:	6e 7f       	andi	r22, 0xFE	; 254
 442:	1a c0       	rjmp	.+52     	; 0x478 <__stack+0x19>
    }
    else if (ENAA_P1 == pipeAddress)
 444:	81 30       	cpi	r24, 0x01	; 1
 446:	21 f4       	brne	.+8      	; 0x450 <rfClearAutoAckForPipe+0x1a>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P1));
 448:	9d de       	rcall	.-710    	; 0x184 <rfReadRegChar>
 44a:	68 2f       	mov	r22, r24
 44c:	6d 7f       	andi	r22, 0xFD	; 253
 44e:	14 c0       	rjmp	.+40     	; 0x478 <__stack+0x19>
    }
    else if (ENAA_P2 == pipeAddress)
 450:	82 30       	cpi	r24, 0x02	; 2
 452:	29 f4       	brne	.+10     	; 0x45e <rfClearAutoAckForPipe+0x28>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P2));
 454:	81 e0       	ldi	r24, 0x01	; 1
 456:	96 de       	rcall	.-724    	; 0x184 <rfReadRegChar>
 458:	68 2f       	mov	r22, r24
 45a:	6b 7f       	andi	r22, 0xFB	; 251
 45c:	0d c0       	rjmp	.+26     	; 0x478 <__stack+0x19>
    }
    else if (ENAA_P3 == pipeAddress)
 45e:	83 30       	cpi	r24, 0x03	; 3
 460:	29 f4       	brne	.+10     	; 0x46c <__stack+0xd>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P3));
 462:	81 e0       	ldi	r24, 0x01	; 1
 464:	8f de       	rcall	.-738    	; 0x184 <rfReadRegChar>
 466:	68 2f       	mov	r22, r24
 468:	67 7f       	andi	r22, 0xF7	; 247
 46a:	06 c0       	rjmp	.+12     	; 0x478 <__stack+0x19>
    }
    else if (ENAA_P4 == pipeAddress)
 46c:	84 30       	cpi	r24, 0x04	; 4
 46e:	39 f4       	brne	.+14     	; 0x47e <__stack+0x1f>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P4));
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	88 de       	rcall	.-752    	; 0x184 <rfReadRegChar>
 474:	68 2f       	mov	r22, r24
 476:	6f 7e       	andi	r22, 0xEF	; 239
 478:	81 e0       	ldi	r24, 0x01	; 1
 47a:	5f de       	rcall	.-834    	; 0x13a <rfWriteRegChar>
 47c:	08 95       	ret
    }
    else if (ENAA_P5 == pipeAddress)
 47e:	85 30       	cpi	r24, 0x05	; 5
 480:	31 f4       	brne	.+12     	; 0x48e <__stack+0x2f>
    {
        rfWriteRegChar(EN_AA, CLEAR_BIT(rfReadRegChar(EN_AA), ENAA_P5));
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	7f de       	rcall	.-770    	; 0x184 <rfReadRegChar>
 486:	68 2f       	mov	r22, r24
 488:	6f 7d       	andi	r22, 0xDF	; 223
 48a:	81 e0       	ldi	r24, 0x01	; 1
 48c:	56 de       	rcall	.-852    	; 0x13a <rfWriteRegChar>
 48e:	08 95       	ret

00000490 <rfSetAutoAckForPipe>:
}

// sets AutoAck on a pipe
void rfSetAutoAckForPipe(uint8_t pipeAddress)
{
    if (ENAA_P0 == pipeAddress)
 490:	88 23       	and	r24, r24
 492:	29 f4       	brne	.+10     	; 0x49e <rfSetAutoAckForPipe+0xe>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P0));
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	76 de       	rcall	.-788    	; 0x184 <rfReadRegChar>
 498:	68 2f       	mov	r22, r24
 49a:	61 60       	ori	r22, 0x01	; 1
 49c:	1a c0       	rjmp	.+52     	; 0x4d2 <rfSetAutoAckForPipe+0x42>
    }
    else if (ENAA_P1 == pipeAddress)
 49e:	81 30       	cpi	r24, 0x01	; 1
 4a0:	21 f4       	brne	.+8      	; 0x4aa <rfSetAutoAckForPipe+0x1a>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P1));
 4a2:	70 de       	rcall	.-800    	; 0x184 <rfReadRegChar>
 4a4:	68 2f       	mov	r22, r24
 4a6:	62 60       	ori	r22, 0x02	; 2
 4a8:	14 c0       	rjmp	.+40     	; 0x4d2 <rfSetAutoAckForPipe+0x42>
    }
    else if (ENAA_P2 == pipeAddress)
 4aa:	82 30       	cpi	r24, 0x02	; 2
 4ac:	29 f4       	brne	.+10     	; 0x4b8 <rfSetAutoAckForPipe+0x28>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P2));
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	69 de       	rcall	.-814    	; 0x184 <rfReadRegChar>
 4b2:	68 2f       	mov	r22, r24
 4b4:	64 60       	ori	r22, 0x04	; 4
 4b6:	0d c0       	rjmp	.+26     	; 0x4d2 <rfSetAutoAckForPipe+0x42>
    }
    else if (ENAA_P3 == pipeAddress)
 4b8:	83 30       	cpi	r24, 0x03	; 3
 4ba:	29 f4       	brne	.+10     	; 0x4c6 <rfSetAutoAckForPipe+0x36>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P3));
 4bc:	81 e0       	ldi	r24, 0x01	; 1
 4be:	62 de       	rcall	.-828    	; 0x184 <rfReadRegChar>
 4c0:	68 2f       	mov	r22, r24
 4c2:	68 60       	ori	r22, 0x08	; 8
 4c4:	06 c0       	rjmp	.+12     	; 0x4d2 <rfSetAutoAckForPipe+0x42>
    }
    else if (ENAA_P4 == pipeAddress)
 4c6:	84 30       	cpi	r24, 0x04	; 4
 4c8:	39 f4       	brne	.+14     	; 0x4d8 <rfSetAutoAckForPipe+0x48>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P4));
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	5b de       	rcall	.-842    	; 0x184 <rfReadRegChar>
 4ce:	68 2f       	mov	r22, r24
 4d0:	60 61       	ori	r22, 0x10	; 16
 4d2:	81 e0       	ldi	r24, 0x01	; 1
 4d4:	32 de       	rcall	.-924    	; 0x13a <rfWriteRegChar>
 4d6:	08 95       	ret
    }
    else if (ENAA_P5 == pipeAddress)
 4d8:	85 30       	cpi	r24, 0x05	; 5
 4da:	31 f4       	brne	.+12     	; 0x4e8 <rfSetAutoAckForPipe+0x58>
    {
        rfWriteRegChar(EN_AA, SET_BIT(rfReadRegChar(EN_AA), ENAA_P5));
 4dc:	81 e0       	ldi	r24, 0x01	; 1
 4de:	52 de       	rcall	.-860    	; 0x184 <rfReadRegChar>
 4e0:	68 2f       	mov	r22, r24
 4e2:	60 62       	ori	r22, 0x20	; 32
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	29 de       	rcall	.-942    	; 0x13a <rfWriteRegChar>
 4e8:	08 95       	ret

000004ea <rfSetToReceiveMode>:
}

// sets the radio to receive mode
void rfSetToReceiveMode(void)
{
    CE_LOW;
 4ea:	c6 98       	cbi	0x18, 6	; 24
    rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), PRIM_RX));
 4ec:	80 e0       	ldi	r24, 0x00	; 0
 4ee:	4a de       	rcall	.-876    	; 0x184 <rfReadRegChar>
 4f0:	68 2f       	mov	r22, r24
 4f2:	61 60       	ori	r22, 0x01	; 1
 4f4:	80 e0       	ldi	r24, 0x00	; 0
 4f6:	21 de       	rcall	.-958    	; 0x13a <rfWriteRegChar>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 4f8:	84 e0       	ldi	r24, 0x04	; 4
 4fa:	91 e0       	ldi	r25, 0x01	; 1
 4fc:	01 97       	sbiw	r24, 0x01	; 1
 4fe:	f1 f7       	brne	.-4      	; 0x4fc <rfSetToReceiveMode+0x12>
    _delay_us(130);
    CE_HIGH;
 500:	c6 9a       	sbi	0x18, 6	; 24
}
 502:	08 95       	ret

00000504 <rfSetToTransmitMode>:
}

// sets the radio to transmit mode
void rfSetToTransmitMode(void)
{
    CE_LOW;
 504:	c6 98       	cbi	0x18, 6	; 24
    rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), PRIM_RX));
 506:	80 e0       	ldi	r24, 0x00	; 0
 508:	3d de       	rcall	.-902    	; 0x184 <rfReadRegChar>
 50a:	68 2f       	mov	r22, r24
 50c:	6e 7f       	andi	r22, 0xFE	; 254
 50e:	80 e0       	ldi	r24, 0x00	; 0
 510:	14 de       	rcall	.-984    	; 0x13a <rfWriteRegChar>
 512:	84 e0       	ldi	r24, 0x04	; 4
 514:	91 e0       	ldi	r25, 0x01	; 1
 516:	01 97       	sbiw	r24, 0x01	; 1
 518:	f1 f7       	brne	.-4      	; 0x516 <rfSetToTransmitMode+0x12>
    _delay_us(130);
}
 51a:	08 95       	ret

0000051c <rfClearInterruptMask>:
}

// clears interrupt mask
void rfClearInterruptMask(uint8_t mask)
{
    if (MASK_RX_DR == mask)
 51c:	86 30       	cpi	r24, 0x06	; 6
 51e:	29 f4       	brne	.+10     	; 0x52a <rfClearInterruptMask+0xe>
    {
        rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), MASK_RX_DR));
 520:	80 e0       	ldi	r24, 0x00	; 0
 522:	30 de       	rcall	.-928    	; 0x184 <rfReadRegChar>
 524:	68 2f       	mov	r22, r24
 526:	6f 7b       	andi	r22, 0xBF	; 191
 528:	06 c0       	rjmp	.+12     	; 0x536 <rfClearInterruptMask+0x1a>
    }
    else if (MASK_TX_DS == mask)
 52a:	85 30       	cpi	r24, 0x05	; 5
 52c:	39 f4       	brne	.+14     	; 0x53c <rfClearInterruptMask+0x20>
    {
        rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), MASK_TX_DS));
 52e:	80 e0       	ldi	r24, 0x00	; 0
 530:	29 de       	rcall	.-942    	; 0x184 <rfReadRegChar>
 532:	68 2f       	mov	r22, r24
 534:	6f 7d       	andi	r22, 0xDF	; 223
 536:	80 e0       	ldi	r24, 0x00	; 0
 538:	00 de       	rcall	.-1024   	; 0x13a <rfWriteRegChar>
 53a:	08 95       	ret
    }
    else if (MASK_MAX_RT == mask)
 53c:	84 30       	cpi	r24, 0x04	; 4
 53e:	31 f4       	brne	.+12     	; 0x54c <rfClearInterruptMask+0x30>
    {
        rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), MASK_MAX_RT));
 540:	80 e0       	ldi	r24, 0x00	; 0
 542:	20 de       	rcall	.-960    	; 0x184 <rfReadRegChar>
 544:	68 2f       	mov	r22, r24
 546:	6f 7e       	andi	r22, 0xEF	; 239
 548:	80 e0       	ldi	r24, 0x00	; 0
 54a:	f7 dd       	rcall	.-1042   	; 0x13a <rfWriteRegChar>
 54c:	08 95       	ret

0000054e <rfSetInterruptMask>:
}

// sets interrupt mask
void rfSetInterruptMask(uint8_t mask)
{
    if (MASK_RX_DR == mask)
 54e:	86 30       	cpi	r24, 0x06	; 6
 550:	29 f4       	brne	.+10     	; 0x55c <rfSetInterruptMask+0xe>
    {
        rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), MASK_RX_DR));
 552:	80 e0       	ldi	r24, 0x00	; 0
 554:	17 de       	rcall	.-978    	; 0x184 <rfReadRegChar>
 556:	68 2f       	mov	r22, r24
 558:	60 64       	ori	r22, 0x40	; 64
 55a:	06 c0       	rjmp	.+12     	; 0x568 <rfSetInterruptMask+0x1a>
    }
    else if (MASK_TX_DS == mask)
 55c:	85 30       	cpi	r24, 0x05	; 5
 55e:	39 f4       	brne	.+14     	; 0x56e <rfSetInterruptMask+0x20>
    {
        rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), MASK_TX_DS));
 560:	80 e0       	ldi	r24, 0x00	; 0
 562:	10 de       	rcall	.-992    	; 0x184 <rfReadRegChar>
 564:	68 2f       	mov	r22, r24
 566:	60 62       	ori	r22, 0x20	; 32
 568:	80 e0       	ldi	r24, 0x00	; 0
 56a:	e7 dd       	rcall	.-1074   	; 0x13a <rfWriteRegChar>
 56c:	08 95       	ret
    }
    else if (MASK_MAX_RT == mask)
 56e:	84 30       	cpi	r24, 0x04	; 4
 570:	31 f4       	brne	.+12     	; 0x57e <rfSetInterruptMask+0x30>
    {
        rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), MASK_MAX_RT));
 572:	80 e0       	ldi	r24, 0x00	; 0
 574:	07 de       	rcall	.-1010   	; 0x184 <rfReadRegChar>
 576:	68 2f       	mov	r22, r24
 578:	60 61       	ori	r22, 0x10	; 16
 57a:	80 e0       	ldi	r24, 0x00	; 0
 57c:	de dd       	rcall	.-1092   	; 0x13a <rfWriteRegChar>
 57e:	08 95       	ret

00000580 <rfSetCrcScheme>:
}

// sets the number of crc bytes
void rfSetCrcScheme(uint8_t scheme)
{
    if (scheme)
 580:	88 23       	and	r24, r24
 582:	31 f0       	breq	.+12     	; 0x590 <rfSetCrcScheme+0x10>
    {
        rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), CRCO));
 584:	80 e0       	ldi	r24, 0x00	; 0
 586:	fe dd       	rcall	.-1028   	; 0x184 <rfReadRegChar>
 588:	68 2f       	mov	r22, r24
 58a:	64 60       	ori	r22, 0x04	; 4
 58c:	80 e0       	ldi	r24, 0x00	; 0
 58e:	d5 dd       	rcall	.-1110   	; 0x13a <rfWriteRegChar>
 590:	08 95       	ret

00000592 <rfDisableCRC>:
 * \return NonReturning
 *
 */
void rfDisableCRC(void)
{
    rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), EN_CRC));
 592:	80 e0       	ldi	r24, 0x00	; 0
 594:	f7 dd       	rcall	.-1042   	; 0x184 <rfReadRegChar>
 596:	68 2f       	mov	r22, r24
 598:	67 7f       	andi	r22, 0xF7	; 247
 59a:	80 e0       	ldi	r24, 0x00	; 0
 59c:	ce dd       	rcall	.-1124   	; 0x13a <rfWriteRegChar>
}
 59e:	08 95       	ret

000005a0 <rfEnableCRC>:
 * \return NonReturning
 *
 */
void rfEnableCRC(void)
{
    rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), EN_CRC));
 5a0:	80 e0       	ldi	r24, 0x00	; 0
 5a2:	f0 dd       	rcall	.-1056   	; 0x184 <rfReadRegChar>
 5a4:	68 2f       	mov	r22, r24
 5a6:	68 60       	ori	r22, 0x08	; 8
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	c7 dd       	rcall	.-1138   	; 0x13a <rfWriteRegChar>
}
 5ac:	08 95       	ret

000005ae <rfSetAddressWidth>:
    rfWriteRegChar(RF_SETUP, SET_VALUE(rfReadRegChar(RF_SETUP), (((1<<3) & dataRate<<3)) | ((1<<5) & dataRate<<5)));
}

// sets receive address width
void rfSetAddressWidth(uint8_t addressWidth)
{
 5ae:	1f 93       	push	r17
 5b0:	18 2f       	mov	r17, r24
    // check bounds
    rfWriteRegChar(SETUP_AW, SET_VALUE(rfReadRegChar(SETUP_AW), addressWidth));
 5b2:	83 e0       	ldi	r24, 0x03	; 3
 5b4:	e7 dd       	rcall	.-1074   	; 0x184 <rfReadRegChar>
 5b6:	18 2b       	or	r17, r24
 5b8:	83 e0       	ldi	r24, 0x03	; 3
 5ba:	61 2f       	mov	r22, r17
 5bc:	be dd       	rcall	.-1156   	; 0x13a <rfWriteRegChar>
}
 5be:	1f 91       	pop	r17
 5c0:	08 95       	ret

000005c2 <rfSetDataRate>:
    rfWriteRegChar(RF_SETUP, SET_VALUE(rfReadRegChar(RF_SETUP), (power<<1)));
}

// sets the transmit data-rate
void rfSetDataRate(uint8_t dataRate)
{
 5c2:	0f 93       	push	r16
 5c4:	1f 93       	push	r17
 5c6:	08 2f       	mov	r16, r24
    // check bounds
    rfWriteRegChar(RF_SETUP, SET_VALUE(rfReadRegChar(RF_SETUP), (((1<<3) & dataRate<<3)) | ((1<<5) & dataRate<<5)));
 5c8:	86 e0       	ldi	r24, 0x06	; 6
 5ca:	dc dd       	rcall	.-1096   	; 0x184 <rfReadRegChar>
 5cc:	10 e0       	ldi	r17, 0x00	; 0
 5ce:	23 e0       	ldi	r18, 0x03	; 3
 5d0:	00 0f       	add	r16, r16
 5d2:	11 1f       	adc	r17, r17
 5d4:	2a 95       	dec	r18
 5d6:	e1 f7       	brne	.-8      	; 0x5d0 <rfSetDataRate+0xe>
 5d8:	60 2f       	mov	r22, r16
 5da:	68 70       	andi	r22, 0x08	; 8
 5dc:	00 0f       	add	r16, r16
 5de:	11 1f       	adc	r17, r17
 5e0:	00 0f       	add	r16, r16
 5e2:	11 1f       	adc	r17, r17
 5e4:	00 72       	andi	r16, 0x20	; 32
 5e6:	60 2b       	or	r22, r16
 5e8:	68 2b       	or	r22, r24
 5ea:	86 e0       	ldi	r24, 0x06	; 6
 5ec:	a6 dd       	rcall	.-1204   	; 0x13a <rfWriteRegChar>
}
 5ee:	1f 91       	pop	r17
 5f0:	0f 91       	pop	r16
 5f2:	08 95       	ret

000005f4 <rfSetTransmitPower>:
    rfWriteRegChar(RF_CH, SET_VALUE(rfReadRegChar(RF_CH), channel));
}

// sets the transmit power
void rfSetTransmitPower(uint8_t power)
{
 5f4:	1f 93       	push	r17
 5f6:	18 2f       	mov	r17, r24
    // check bounds
    rfWriteRegChar(RF_SETUP, SET_VALUE(rfReadRegChar(RF_SETUP), (power<<1)));
 5f8:	86 e0       	ldi	r24, 0x06	; 6
 5fa:	c4 dd       	rcall	.-1144   	; 0x184 <rfReadRegChar>
 5fc:	11 0f       	add	r17, r17
 5fe:	18 2b       	or	r17, r24
 600:	86 e0       	ldi	r24, 0x06	; 6
 602:	61 2f       	mov	r22, r17
 604:	9a dd       	rcall	.-1228   	; 0x13a <rfWriteRegChar>
}
 606:	1f 91       	pop	r17
 608:	08 95       	ret

0000060a <rfSetChannel>:
    return status;
}

// sets the radio frequency
void rfSetChannel(uint8_t channel)
{
 60a:	1f 93       	push	r17
 60c:	18 2f       	mov	r17, r24
    // check bounds
    rfWriteRegChar(RF_CH, SET_VALUE(rfReadRegChar(RF_CH), channel));
 60e:	85 e0       	ldi	r24, 0x05	; 5
 610:	b9 dd       	rcall	.-1166   	; 0x184 <rfReadRegChar>
 612:	18 2b       	or	r17, r24
 614:	85 e0       	ldi	r24, 0x05	; 5
 616:	61 2f       	mov	r22, r17
 618:	90 dd       	rcall	.-1248   	; 0x13a <rfWriteRegChar>
}
 61a:	1f 91       	pop	r17
 61c:	08 95       	ret

0000061e <rfToPowerDown>:
}

// changes the state of the transceiver to powerDown mode
void rfToPowerDown(void)
{
    rfWriteRegChar(CONFIG, CLEAR_BIT(rfReadRegChar(CONFIG), PWR_UP));
 61e:	80 e0       	ldi	r24, 0x00	; 0
 620:	b1 dd       	rcall	.-1182   	; 0x184 <rfReadRegChar>
 622:	68 2f       	mov	r22, r24
 624:	6d 7f       	andi	r22, 0xFD	; 253
 626:	80 e0       	ldi	r24, 0x00	; 0
 628:	88 dd       	rcall	.-1264   	; 0x13a <rfWriteRegChar>
    CE_LOW;
 62a:	c6 98       	cbi	0x18, 6	; 24
}
 62c:	08 95       	ret

0000062e <rfToStandbyOne>:
}

// changes the state of the transceiver to standby mode one
void rfToStandbyOne(void)
{
    rfWriteRegChar(CONFIG, SET_BIT(rfReadRegChar(CONFIG), PWR_UP));
 62e:	80 e0       	ldi	r24, 0x00	; 0
 630:	a9 dd       	rcall	.-1198   	; 0x184 <rfReadRegChar>
 632:	68 2f       	mov	r22, r24
 634:	62 60       	ori	r22, 0x02	; 2
 636:	80 e0       	ldi	r24, 0x00	; 0
 638:	80 dd       	rcall	.-1280   	; 0x13a <rfWriteRegChar>
    CE_LOW;
 63a:	c6 98       	cbi	0x18, 6	; 24
 63c:	80 ed       	ldi	r24, 0xD0	; 208
 63e:	97 e0       	ldi	r25, 0x07	; 7
 640:	28 ec       	ldi	r18, 0xC8	; 200
 642:	30 e0       	ldi	r19, 0x00	; 0
 644:	f9 01       	movw	r30, r18
 646:	31 97       	sbiw	r30, 0x01	; 1
 648:	f1 f7       	brne	.-4      	; 0x646 <rfToStandbyOne+0x18>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 64a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 64c:	d9 f7       	brne	.-10     	; 0x644 <rfToStandbyOne+0x16>

    _delay_ms(200);
}
 64e:	08 95       	ret

00000650 <rfStartListening>:
}

// continuously listens
void rfStartListening(void)
{
    rfToStandbyOne();
 650:	ee df       	rcall	.-36     	; 0x62e <rfToStandbyOne>
    rfSetToReceiveMode();
 652:	4b df       	rcall	.-362    	; 0x4ea <rfSetToReceiveMode>
    rfState = RF_LISTENING;
 654:	81 e0       	ldi	r24, 0x01	; 1
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	90 93 65 00 	sts	0x0065, r25
 65c:	80 93 64 00 	sts	0x0064, r24
}
 660:	08 95       	ret

00000662 <rfTransmit>:
volatile uint8_t *rfPtrBuffer = rfBuffer;
rfState_t rfState = RF_IDLE;

// handles the transmission of rfPacket
void rfTransmit(uint8_t* buff, uint8_t len)
{
 662:	ff 92       	push	r15
 664:	0f 93       	push	r16
 666:	1f 93       	push	r17
 668:	8c 01       	movw	r16, r24
 66a:	f6 2e       	mov	r15, r22
    rfToStandbyOne();
 66c:	e0 df       	rcall	.-64     	; 0x62e <rfToStandbyOne>
    rfWritePayload(buff, len);
 66e:	c8 01       	movw	r24, r16
 670:	6f 2d       	mov	r22, r15
 672:	4c dd       	rcall	.-1384   	; 0x10c <rfWritePayload>
    rfSetToTransmitMode();
 674:	47 df       	rcall	.-370    	; 0x504 <rfSetToTransmitMode>
    CE_HIGH;
 676:	c6 9a       	sbi	0x18, 6	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 678:	8a e1       	ldi	r24, 0x1A	; 26
 67a:	8a 95       	dec	r24
 67c:	f1 f7       	brne	.-4      	; 0x67a <rfTransmit+0x18>
    _delay_us(10);
    CE_LOW;
 67e:	c6 98       	cbi	0x18, 6	; 24
	LED_ON;

	rfState = RF_TRANSMITTING;
 680:	83 e0       	ldi	r24, 0x03	; 3
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	90 93 65 00 	sts	0x0065, r25
 688:	80 93 64 00 	sts	0x0064, r24
}
 68c:	1f 91       	pop	r17
 68e:	0f 91       	pop	r16
 690:	ff 90       	pop	r15
 692:	08 95       	ret

00000694 <rfReadRegBuff>:
    CE_LOW;
}

// reads the register and writes to the buffer
uint8_t rfReadRegBuff(uint8_t reg, uint8_t* buf, uint8_t len)
{
 694:	0f 93       	push	r16
 696:	1f 93       	push	r17
 698:	cf 93       	push	r28
 69a:	df 93       	push	r29
 69c:	eb 01       	movw	r28, r22
 69e:	14 2f       	mov	r17, r20
    uint8_t status;

    CSN_LOW;
 6a0:	c7 98       	cbi	0x18, 7	; 24
    status = spiSendData( R_REGISTER | reg );
 6a2:	4a d0       	rcall	.+148    	; 0x738 <spiSendData>
 6a4:	08 2f       	mov	r16, r24
 6a6:	04 c0       	rjmp	.+8      	; 0x6b0 <rfReadRegBuff+0x1c>
    while ( len-- )
        *buf++ = spiSendData(0xff);
 6a8:	8f ef       	ldi	r24, 0xFF	; 255
 6aa:	46 d0       	rcall	.+140    	; 0x738 <spiSendData>
 6ac:	89 93       	st	Y+, r24
 6ae:	11 50       	subi	r17, 0x01	; 1
{
    uint8_t status;

    CSN_LOW;
    status = spiSendData( R_REGISTER | reg );
    while ( len-- )
 6b0:	11 23       	and	r17, r17
 6b2:	d1 f7       	brne	.-12     	; 0x6a8 <rfReadRegBuff+0x14>
        *buf++ = spiSendData(0xff);
    CSN_HIGH;
 6b4:	c7 9a       	sbi	0x18, 7	; 24

    return status;
}
 6b6:	80 2f       	mov	r24, r16
 6b8:	df 91       	pop	r29
 6ba:	cf 91       	pop	r28
 6bc:	1f 91       	pop	r17
 6be:	0f 91       	pop	r16
 6c0:	08 95       	ret

000006c2 <app>:
    if (appState == APP_DATA_RECEIVED)
    {
        processData();
    }
    // write app here
}
 6c2:	08 95       	ret

000006c4 <processData>:

void processData(void)
{
    //uint8_t appBuffer[32];

}
 6c4:	08 95       	ret

000006c6 <appTransmit>:

void appTransmit(uint8_t *data, uint8_t len)
{
    rfTransmit(data,len);
 6c6:	cd df       	rcall	.-102    	; 0x662 <rfTransmit>
    while(rfState != RF_TRANSMIT_SUCCESS);
 6c8:	80 91 64 00 	lds	r24, 0x0064
 6cc:	90 91 65 00 	lds	r25, 0x0065
 6d0:	04 97       	sbiw	r24, 0x04	; 4
 6d2:	11 f4       	brne	.+4      	; 0x6d8 <appTransmit+0x12>
    rfStartListening();
 6d4:	bd df       	rcall	.-134    	; 0x650 <rfStartListening>
}
 6d6:	08 95       	ret
 6d8:	ff cf       	rjmp	.-2      	; 0x6d8 <appTransmit+0x12>

000006da <init>:


void init(void)
{
	// move from power down to standby mode one
	rfToStandbyOne();
 6da:	a9 df       	rcall	.-174    	; 0x62e <rfToStandbyOne>
	// set the channel/frequency
	rfSetChannel(RF_CHANNEL);
 6dc:	8a e1       	ldi	r24, 0x1A	; 26
 6de:	95 df       	rcall	.-214    	; 0x60a <rfSetChannel>
	// set the mask bits. MASK_MAX_RT is set because we use auto ack
	rfSetInterruptMask(MASK_RX_DR | MASK_TX_DS | MASK_MAX_RT);
 6e0:	87 e0       	ldi	r24, 0x07	; 7
 6e2:	35 df       	rcall	.-406    	; 0x54e <rfSetInterruptMask>
	// enable auto ack for pipe P0
	rfSetAutoAckForPipe(ENAA_P0);
 6e4:	80 e0       	ldi	r24, 0x00	; 0
 6e6:	d4 de       	rcall	.-600    	; 0x490 <rfSetAutoAckForPipe>
	// enable RX for pipe P0
	rfEnablePipeForRx(ERX_P0);
 6e8:	80 e0       	ldi	r24, 0x00	; 0
 6ea:	78 de       	rcall	.-784    	; 0x3dc <rfEnablePipeForRx>
	// enable reception of dynamic payload
	rfEnableGlobalDynamicPayload();
 6ec:	c7 dd       	rcall	.-1138   	; 0x27c <rfEnableGlobalDynamicPayload>
	// enable dynamic payload for pipe P0
	rfSetDynamicPayloadForPipe(DPL_P0);
 6ee:	80 e0       	ldi	r24, 0x00	; 0
 6f0:	fa dd       	rcall	.-1036   	; 0x2e6 <rfSetDynamicPayloadForPipe>
	// enable listening
	rfStartListening();
 6f2:	ae df       	rcall	.-164    	; 0x650 <rfStartListening>
	// enable global interrupts
	sei();
 6f4:	78 94       	sei
}
 6f6:	08 95       	ret

000006f8 <main>:

int main(void)
{
    init();
 6f8:	f0 df       	rcall	.-32     	; 0x6da <init>
 6fa:	ff cf       	rjmp	.-2      	; 0x6fa <main+0x2>

000006fc <spiInit>:

// initializing spi
void spiInit(void)
{
    // enabling spi
    SPCR |= (1<<SPE);
 6fc:	6e 9a       	sbi	0x0d, 6	; 13
    // selecting master mode
    SPCR |= (1<<MSTR);
 6fe:	6c 9a       	sbi	0x0d, 4	; 13
    // making pins output, the miso pin will be made input when spi is enabled
    SPI_DDR |= (1<<MOSI) | (1<<SCK);
 700:	87 b3       	in	r24, 0x17	; 23
 702:	88 62       	ori	r24, 0x28	; 40
 704:	87 bb       	out	0x17, r24	; 23
}
 706:	08 95       	ret

00000708 <spiSendBuffer>:

// sending the data stored in the buffer.
void spiSendBuffer(uint8_t *buffer, uint8_t len)
{
 708:	fc 01       	movw	r30, r24
    do
    {
        SPI_DATA = *buffer;
 70a:	80 81       	ld	r24, Z
 70c:	8f b9       	out	0x0f, r24	; 15
        SPI_SEND;
 70e:	77 9b       	sbis	0x0e, 7	; 14
 710:	fe cf       	rjmp	.-4      	; 0x70e <spiSendBuffer+0x6>
        buffer++;
    }
    while(len--);
 712:	66 23       	and	r22, r22
 714:	19 f0       	breq	.+6      	; 0x71c <spiSendBuffer+0x14>
{
    do
    {
        SPI_DATA = *buffer;
        SPI_SEND;
        buffer++;
 716:	31 96       	adiw	r30, 0x01	; 1
    }
    while(len--);
 718:	61 50       	subi	r22, 0x01	; 1
 71a:	f7 cf       	rjmp	.-18     	; 0x70a <spiSendBuffer+0x2>
 71c:	08 95       	ret

0000071e <spiGetBuffer>:
}

// gets the data from the radio and stores in the buffer
void spiGetBuffer(uint8_t *buffer, uint8_t len)
{
 71e:	fc 01       	movw	r30, r24
    do
    {
        SPI_DATA = 0xff;
 720:	9f ef       	ldi	r25, 0xFF	; 255
 722:	9f b9       	out	0x0f, r25	; 15
        SPI_SEND;
 724:	77 9b       	sbis	0x0e, 7	; 14
 726:	fe cf       	rjmp	.-4      	; 0x724 <spiGetBuffer+0x6>
        *buffer = SPI_DATA;
 728:	8f b1       	in	r24, 0x0f	; 15
 72a:	80 83       	st	Z, r24
        buffer++;
    }
    while(len--);
 72c:	66 23       	and	r22, r22
 72e:	19 f0       	breq	.+6      	; 0x736 <spiGetBuffer+0x18>
    do
    {
        SPI_DATA = 0xff;
        SPI_SEND;
        *buffer = SPI_DATA;
        buffer++;
 730:	31 96       	adiw	r30, 0x01	; 1
    }
    while(len--);
 732:	61 50       	subi	r22, 0x01	; 1
 734:	f6 cf       	rjmp	.-20     	; 0x722 <spiGetBuffer+0x4>
 736:	08 95       	ret

00000738 <spiSendData>:
// sends any command
uint8_t spiSendData(uint8_t data)
{
    uint8_t result;

    SPI_DATA = data;
 738:	8f b9       	out	0x0f, r24	; 15
    SPI_SEND;
 73a:	77 9b       	sbis	0x0e, 7	; 14
 73c:	fe cf       	rjmp	.-4      	; 0x73a <spiSendData+0x2>
    result = SPI_DATA;
 73e:	8f b1       	in	r24, 0x0f	; 15
    // returns the status
    return result;
}
 740:	08 95       	ret

00000742 <_exit>:
 742:	f8 94       	cli

00000744 <__stop_program>:
 744:	ff cf       	rjmp	.-2      	; 0x744 <__stop_program>
